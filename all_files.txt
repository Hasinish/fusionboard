
===== FILE: all_files.txt =====


===== FILE: backend\.env =====
MONGO_URI=mongodb+srv://hasinishrak2015_db_user:MUb26jLpTSng8XtW@cluster0.qgo2q3t.mongodb.net/fusionboard_db?appName=Cluster0
PORT=5001
JWT_SECRET=abc123

===== FILE: backend\.gitignore =====
# Node modules
node_modules/


# Logs
npm-debug.log*
yarn-debug.log*
pnpm-debug.log*

# OS files
.DS_Store

.env

===== FILE: backend\package.json =====
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "src/server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon src/server.js",
    "start": "node src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module",
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.3",
    "mongoose": "^8.14.3",


    "socket.io": "^4.8.1"


  },
  "devDependencies": {
    "nodemon": "^3.1.11"
  }
}


===== FILE: backend\src\server.js =====
// backend/src/server.js
import express from "express";
import cors from "cors";
import http from "http";
import { Server } from "socket.io";
import jwt from "jsonwebtoken";
import dotenv from "dotenv";

import connectDB from "./config/db.js";

import authRoutes from "./routes/authRoutes.js";
import workspaceRoutes from "./routes/workspaceRoutes.js";
import notificationRoutes from "./routes/notificationRoutes.js";
import boardRoutes from "./routes/boardRoutes.js";

import Message from "./models/Message.js";
import Board from "./models/Board.js";
import Workspace from "./models/Workspace.js";
import User from "./models/User.js";

dotenv.config();

const app = express();
app.use(cors());
app.use(express.json());

connectDB();

app.get("/", (req, res) => {
  res.send("Backend is running âœ…");
});

app.use("/api/auth", authRoutes);
app.use("/api/workspaces", workspaceRoutes);
app.use("/api/notifications", notificationRoutes);
app.use("/api/boards", boardRoutes);

const server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"],
  },
});

// -------------------------
// Auth middleware for sockets (JWT)
// -------------------------
io.use(async (socket, next) => {
  try {
    const token =
      socket.handshake.auth?.token ||
      socket.handshake.headers?.authorization?.replace("Bearer ", "");

    if (!token) return next(new Error("No token"));

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    socket.userId = String(decoded.id);

    // Fetch user name (used by voice participants list)
    try {
      const u = await User.findById(socket.userId).select("name").lean();
      socket.userName = u?.name ? String(u.name) : "User";
    } catch {
      socket.userName = "User";
    }

    return next();
  } catch {
    return next(new Error("Invalid token"));
  }
});

// -------------------------
// Helpers
// -------------------------
async function ensureMember(workspaceId, userId) {
  try {
    const ws = await Workspace.findById(workspaceId).select("owner members").lean();
    if (!ws) return { ok: false, message: "Workspace not found" };

    const uid = String(userId);
    const ownerOk = ws.owner && String(ws.owner) === uid;
    const memberOk = Array.isArray(ws.members) && ws.members.some((m) => String(m) === uid);

    if (!ownerOk && !memberOk) {
      return { ok: false, message: "Not a member of this workspace" };
    }

    return { ok: true };
  } catch {
    return { ok: false, message: "Membership check failed" };
  }
}

// ---------- LIVE CURSOR helpers ----------
const CURSOR_COLORS = [
  "#ef4444",
  "#f97316",
  "#f59e0b",
  "#22c55e",
  "#06b6d4",
  "#3b82f6",
  "#8b5cf6",
  "#ec4899",
];

function pickColor(key) {
  const s = String(key || "");
  let hash = 0;
  for (let i = 0; i < s.length; i++) hash = (hash * 31 + s.charCodeAt(i)) >>> 0;
  return CURSOR_COLORS[hash % CURSOR_COLORS.length];
}

// socket.id -> { boardId, userId, name, color }
const cursorState = new Map();

// ---------- VOICE helpers ----------
const voiceRoomKey = (roomId) => `voice:${roomId}`;

async function emitVoiceParticipants(roomKey) {
  // fetchSockets gives all sockets currently in the room
  const sockets = await io.in(roomKey).fetchSockets();

  const participants = sockets.map((s) => ({
    peerId: s.id,
    name: s.userName || "User",
  }));

  // Main event your frontend expects
  io.to(roomKey).emit("voice:participants:update", { participants });

  // Backward compat (harmless if unused)
  io.to(roomKey).emit("voice:participants", { participants });
}

io.on("connection", (socket) => {
  // -------------------------
  // WORKSPACE CHAT
  // -------------------------
  socket.on("workspace:join", async ({ workspaceId }, ack) => {
    try {
      const check = await ensureMember(workspaceId, socket.userId);
      if (!check.ok) {
        if (ack) ack({ ok: false, message: check.message });
        return;
      }
      socket.join(`ws:${workspaceId}`);
      if (ack) ack({ ok: true });
    } catch {
      if (ack) ack({ ok: false, message: "Join failed" });
    }
  });

  socket.on("chat:send", async ({ workspaceId, text }, ack) => {
    try {
      const clean = String(text || "").trim();
      if (!clean) {
        if (ack) ack({ ok: false, message: "Empty message" });
        return;
      }

      const check = await ensureMember(workspaceId, socket.userId);
      if (!check.ok) {
        if (ack) ack({ ok: false, message: check.message });
        return;
      }

      const msg = await Message.create({
        workspace: workspaceId,
        sender: socket.userId,
        text: clean,
      });

      const full = await Message.findById(msg._id)
        .populate("sender", "name email")
        .lean();

      io.to(`ws:${workspaceId}`).emit("chat:new", full);
      if (ack) ack({ ok: true });
    } catch (e) {
      console.error("chat:send error:", e);
      if (ack) ack({ ok: false, message: "Send failed" });
    }
  });

  // -------------------------
  // WHITEBOARD JOIN
  // -------------------------
  socket.on("joinBoard", ({ boardId, user }) => {
    if (!boardId) return;

    const name = user?.name ? String(user.name) : "User";
    const userId = socket.userId; // stable per account (from JWT)
    const color = pickColor(userId);

    cursorState.set(socket.id, { boardId, userId, name, color });

    socket.join(`board:${boardId}`);

    // tell others this user joined (cursor exists)
    socket.to(`board:${boardId}`).emit("cursorJoin", { userId, name, color });
  });

  // -------------------------
  // WHITEBOARD DRAW + AUTOSAVE
  // -------------------------
  socket.on("draw", async ({ boardId, strokes }) => {
    try {
      if (!boardId) return;
      socket.to(`board:${boardId}`).emit("draw", strokes);

      // autosave
      await Board.findByIdAndUpdate(boardId, { strokes }, { new: false });
    } catch (e) {
      console.error("draw error:", e);
    }
  });

  socket.on("clearBoard", async ({ boardId }) => {
    try {
      if (!boardId) return;
      socket.to(`board:${boardId}`).emit("clearBoard");
      await Board.findByIdAndUpdate(boardId, { strokes: [] }, { new: false });
    } catch (e) {
      console.error("clearBoard error:", e);
    }
  });

  // -------------------------
  // LIVE CURSOR MOVE
  // -------------------------
  socket.on("cursorMove", ({ boardId, x, y }) => {
    const st = cursorState.get(socket.id);
    if (!st || st.boardId !== boardId) return;

    socket.to(`board:${boardId}`).emit("cursorMove", {
      userId: st.userId,
      x,
      y,
    });
  });

  // -------------------------
  // WHITEBOARD LEAVE (cursor)
  // -------------------------
  function leaveCursor() {
    const st = cursorState.get(socket.id);
    if (!st) return;
    cursorState.delete(socket.id);

    socket.to(`board:${st.boardId}`).emit("cursorLeave", {
      userId: st.userId,
    });
  }

  socket.on("leaveBoard", () => {
    leaveCursor();
  });

  // -------------------------
  // âœ… VOICE CHAT (WebRTC signaling)
  // -------------------------
  socket.on("voice:join", async ({ roomId }, ack) => {
    try {
      if (!roomId) {
        if (ack) ack({ ok: false, message: "Missing roomId" });
        return;
      }

      // roomId is your workspace id
      const check = await ensureMember(roomId, socket.userId);
      if (!check.ok) {
        if (ack) ack({ ok: false, message: check.message });
        return;
      }

      const roomKey = voiceRoomKey(roomId);

      // remember joined rooms (for disconnect cleanup)
      if (!socket.data.voiceRooms) socket.data.voiceRooms = new Set();
      socket.data.voiceRooms.add(roomKey);

      socket.join(roomKey);

      // optional: tell others someone joined
      socket.to(roomKey).emit("voice:peer-joined", { peerId: socket.id });

      await emitVoiceParticipants(roomKey);

      if (ack) ack({ ok: true });
    } catch (e) {
      console.error("voice:join error:", e);
      if (ack) ack({ ok: false, message: "Voice join failed" });
    }
  });

  socket.on("voice:leave", async ({ roomId }, ack) => {
    try {
      if (!roomId) {
        if (ack) ack({ ok: false, message: "Missing roomId" });
        return;
      }

      const roomKey = voiceRoomKey(roomId);

      socket.leave(roomKey);

      if (socket.data.voiceRooms) socket.data.voiceRooms.delete(roomKey);

      socket.to(roomKey).emit("voice:peer-left", { peerId: socket.id });

      await emitVoiceParticipants(roomKey);

      if (ack) ack({ ok: true });
    } catch (e) {
      console.error("voice:leave error:", e);
      if (ack) ack({ ok: false, message: "Voice leave failed" });
    }
  });

  socket.on("voice:signal", ({ to, data }) => {
    // Forward signaling messages to the target peer (offer/answer/ice)
    if (!to) return;
    io.to(to).emit("voice:signal", { from: socket.id, data });
  });

  // -------------------------
  // DISCONNECT (keep ALL features)
  // -------------------------
  socket.on("disconnect", async () => {
    // 1) cursor cleanup
    leaveCursor();

    // 2) voice cleanup + participants update
    try {
      const rooms = socket.data.voiceRooms ? Array.from(socket.data.voiceRooms) : [];
      for (const roomKey of rooms) {
        // let others remove this peer
        socket.to(roomKey).emit("voice:peer-left", { peerId: socket.id });
        await emitVoiceParticipants(roomKey);
      }
    } catch (e) {
      console.error("voice disconnect cleanup error:", e);
    }
  });
});

const PORT = process.env.PORT || 5001;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});


===== FILE: backend\src\config\db.js =====
import mongoose from "mongoose";

export const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGO_URI);
        
        console.log("MONGODB CONNECTED SUCCESSFULLY!");
    } catch (error) {
        console.error("Error connecting to MONGODB", error);
        process.exit(1); 
    }
};

===== FILE: backend\src\controllers\authController.js =====
import User from "../models/User.js";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";

export async function register(req, res) {
  try {
    const { name, email, password } = req.body;

    // Check existing user
    const exists = await User.findOne({ email });
    if (exists) return res.status(400).json({ message: "Email already used" });

    // Hash password
    const hashed = await bcrypt.hash(password, 10);

    await User.create({ name, email, password: hashed });

    res.json({ message: "Registered successfully" });
  } catch (e) {
    res.status(500).json({ message: "Server error" });
  }
}

export async function login(req, res) {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Invalid credentials" });

    const match = await bcrypt.compare(password, user.password);
    if (!match) return res.status(400).json({ message: "Invalid credentials" });

    // Create token
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET);

    // Send token + basic user info
    res.json({
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
      },
    });
  } catch (e) {
    res.status(500).json({ message: "Server error" });
  }
}

// UPDATE LOGGED-IN USER PROFILE
export async function updateMe(req, res) {
  try {
    const userId = req.userId;
    const { name, email } = req.body;

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ message: "User not found" });

    // If email is changed, check uniqueness
    if (email && email !== user.email) {
      const exists = await User.findOne({ email });
      if (exists) {
        return res.status(400).json({ message: "Email already used" });
      }
      user.email = email;
    }

    if (name) {
      user.name = name;
    }

    await user.save();

    return res.json({
      message: "Profile updated successfully",
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
      },
    });
  } catch (e) {
    return res.status(500).json({ message: "Server error" });
  }
}


===== FILE: backend\src\controllers\boardController.js =====
import Board from "../models/Board.js";
import Workspace from "../models/Workspace.js";

async function ensureMember(userId, workspaceId) {
  const ws = await Workspace.findOne({
    _id: workspaceId,
    "members.user": userId,
  }).lean();
  return !!ws;
}

// POST /api/boards  { workspaceId, title? }
export async function createBoard(req, res) {
  try {
    const userId = req.userId;
    const { workspaceId, title } = req.body;

    if (!workspaceId) {
      return res.status(400).json({ message: "workspaceId is required" });
    }

    const ok = await ensureMember(userId, workspaceId);
    if (!ok) {
      return res.status(403).json({ message: "Not allowed" });
    }

    const board = await Board.create({
      workspace: workspaceId,
      title: title || "Untitled Board",
      segments: [],
    });

    return res.status(201).json(board);
  } catch (e) {
    console.error("createBoard error:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

// GET /api/boards/workspace/:workspaceId
export async function listBoards(req, res) {
  try {
    const userId = req.userId;
    const { workspaceId } = req.params;

    const ok = await ensureMember(userId, workspaceId);
    if (!ok) return res.status(403).json({ message: "Not allowed" });

    const boards = await Board.find({ workspace: workspaceId })
      .sort({ updatedAt: -1 })
      .select("_id title updatedAt createdAt")
      .lean();

    return res.json(boards);
  } catch (e) {
    console.error("listBoards error:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

// GET /api/boards/:boardId
export async function getBoard(req, res) {
  try {
    const userId = req.userId;
    const { boardId } = req.params;

    const board = await Board.findById(boardId).lean();
    if (!board) return res.status(404).json({ message: "Board not found" });

    const ok = await ensureMember(userId, board.workspace);
    if (!ok) return res.status(403).json({ message: "Not allowed" });

    return res.json(board);
  } catch (e) {
    console.error("getBoard error:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

// PUT /api/boards/:boardId/save  { segments }
export async function saveBoard(req, res) {
  try {
    const userId = req.userId;
    const { boardId } = req.params;
    const { segments } = req.body;

    const board = await Board.findById(boardId);
    if (!board) return res.status(404).json({ message: "Board not found" });

    const ok = await ensureMember(userId, board.workspace);
    if (!ok) return res.status(403).json({ message: "Not allowed" });

    board.segments = Array.isArray(segments) ? segments : [];
    await board.save();

    return res.json({ message: "Board saved", updatedAt: board.updatedAt });
  } catch (e) {
    console.error("saveBoard error:", e);
    return res.status(500).json({ message: "Server error" });
  }
}


===== FILE: backend\src\controllers\chatController.js =====
// backend/src/controllers/chatController.js
import Workspace from "../models/Workspace.js";
import Message from "../models/Message.js";

async function ensureMember(workspaceId, userId) {
  const ws = await Workspace.findById(workspaceId).lean();
  if (!ws) return { ok: false, status: 404, message: "Workspace not found" };

  const isMember = (ws.members || []).some(
    (m) => String(m.user) === String(userId)
  );
  if (!isMember) return { ok: false, status: 403, message: "Not allowed" };

  return { ok: true, workspace: ws };
}

// GET /api/workspaces/:id/messages?limit=50&before=ISO_DATE
export async function getWorkspaceMessages(req, res) {
  try {
    const userId = req.userId;
    const workspaceId = req.params.id;

    const check = await ensureMember(workspaceId, userId);
    if (!check.ok) {
      return res.status(check.status).json({ message: check.message });
    }

    const limitRaw = Number(req.query.limit || 50);
    const limit = Math.min(Math.max(limitRaw, 1), 200);

    const before = req.query.before ? new Date(req.query.before) : null;
    const filter = { workspace: workspaceId };
    if (before && !isNaN(before.getTime())) {
      filter.createdAt = { $lt: before };
    }

    // Fetch latest first, then reverse so UI shows oldest -> newest
    const msgs = await Message.find(filter)
      .sort({ createdAt: -1 })
      .limit(limit)
      .populate("sender", "name email")
      .lean();

    return res.json(msgs.reverse());
  } catch (e) {
    console.error("getWorkspaceMessages error:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

export { ensureMember };


===== FILE: backend\src\controllers\invitationController.js =====
import Invitation from "../models/Invitation.js";
import Workspace from "../models/Workspace.js";

// Get pending invitations for logged-in user
export async function getMyInvitations(req, res) {
  try {
    const userId = req.userId;

    const invitations = await Invitation.find({
      invitedUser: userId,
      status: "pending",
    })
      .sort({ createdAt: -1 })
      .populate("workspace", "name")
      .populate("invitedBy", "name email")
      .lean();

    return res.json(invitations);
  } catch (e) {
    console.error("Error fetching invitations:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

export async function acceptInvitation(req, res) {
  try {
    const userId = req.userId;
    const { id } = req.params;

    const invitation = await Invitation.findOne({
      _id: id,
      invitedUser: userId,
    });

    if (!invitation) {
      return res.status(404).json({ message: "Invitation not found" });
    }

    if (invitation.status !== "pending") {
      return res.status(400).json({ message: "Invitation already processed" });
    }

    invitation.status = "accepted";
    await invitation.save();

    const workspace = await Workspace.findById(invitation.workspace);
    if (!workspace) {
      return res.status(404).json({ message: "Workspace not found" });
    }

    const alreadyMember = workspace.members.some(
      (m) => String(m.user) === String(userId)
    );
    if (!alreadyMember) {
      // Default role for new members is viewer
      workspace.members.push({ user: userId, role: "viewer" });
      await workspace.save();
    }

    return res.json({ message: "Invitation accepted" });
  } catch (e) {
    console.error("Error accepting invitation:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

export async function rejectInvitation(req, res) {
  try {
    const userId = req.userId;
    const { id } = req.params;

    const invitation = await Invitation.findOne({
      _id: id,
      invitedUser: userId,
    });

    if (!invitation) {
      return res.status(404).json({ message: "Invitation not found" });
    }

    if (invitation.status !== "pending") {
      return res.status(400).json({ message: "Invitation already processed" });
    }

    invitation.status = "rejected";
    await invitation.save();

    return res.json({ message: "Invitation rejected" });
  } catch (e) {
    console.error("Error rejecting invitation:", e);
    return res.status(500).json({ message: "Server error" });
  }
}



===== FILE: backend\src\controllers\workspaceController.js =====
// backend/src/controllers/workspaceController.js
import Workspace from "../models/Workspace.js";
import User from "../models/User.js";
import Invitation from "../models/Invitation.js";

const ONLINE_THRESHOLD_MS = 1000 * 60 * 5; // 5 minutes

// Create a new workspace and send invitations
export async function createWorkspace(req, res) {
  try {
    const userId = req.userId;
    const { name, description, memberEmails } = req.body;

    if (!name) {
      return res.status(400).json({ message: "Workspace name is required" });
    }

    const owner = await User.findById(userId);
    if (!owner) {
      return res.status(404).json({ message: "Owner user not found" });
    }

    // Create workspace with owner as first member (role: owner)
    const workspace = await Workspace.create({
      name,
      description: description || "",
      owner: owner._id,
      members: [
        {
          user: owner._id,
          role: "owner",
        },
      ],
    });

    // memberEmails is expected as an array of strings
    if (Array.isArray(memberEmails)) {
      for (const rawEmail of memberEmails) {
        const email = String(rawEmail).trim().toLowerCase();
        if (!email) continue;
        if (email === owner.email.toLowerCase()) continue; // skip self

        const invitedUser = await User.findOne({ email });
        if (!invitedUser) {
          // If user not registered, skip silently for now
          continue;
        }

        // Avoid duplicate invitation
        const existingInvite = await Invitation.findOne({
          workspace: workspace._id,
          invitedUser: invitedUser._id,
          status: "pending",
        });

        if (!existingInvite) {
          await Invitation.create({
            workspace: workspace._id,
            invitedBy: owner._id,
            invitedUser: invitedUser._id,
          });
        }
      }
    }

    return res.status(201).json({
      message: "Workspace created successfully",
      workspace,
    });
  } catch (e) {
    console.error("Error creating workspace:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

// Invite new members (by email) from an existing workspace (owner only)
export async function inviteMembers(req, res) {
  try {
    const userId = req.userId;
    const { id } = req.params;
    const { memberEmails } = req.body;

    if (!Array.isArray(memberEmails) || memberEmails.length === 0) {
      return res.status(400).json({ message: "No emails provided" });
    }

    const workspace = await Workspace.findById(id)
      .populate("owner", "email")
      .populate("members.user", "email");

    if (!workspace) {
      return res.status(404).json({ message: "Workspace not found" });
    }

    if (String(workspace.owner._id) !== String(userId)) {
      return res.status(403).json({ message: "Only owner can invite members" });
    }

    const ownerEmail = workspace.owner.email.toLowerCase();

    for (const rawEmail of memberEmails) {
      const email = String(rawEmail).trim().toLowerCase();
      if (!email) continue;
      if (email === ownerEmail) continue;

      const invitedUser = await User.findOne({ email });
      if (!invitedUser) {
        continue;
      }

      const alreadyMember = workspace.members.some(
        (m) =>
          String(m.user._id || m.user) === String(invitedUser._id)
      );
      if (alreadyMember) continue;

      const existingInvite = await Invitation.findOne({
        workspace: workspace._id,
        invitedUser: invitedUser._id,
        status: "pending",
      });
      if (existingInvite) continue;

      await Invitation.create({
        workspace: workspace._id,
        invitedBy: workspace.owner._id,
        invitedUser: invitedUser._id,
      });
    }

    return res.json({ message: "Invitations sent (for registered users)." });
  } catch (e) {
    console.error("Error inviting members:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

// Get all workspaces where the user is a member
export async function getMyWorkspaces(req, res) {
  try {
    const userId = req.userId;

    const workspaces = await Workspace.find({
      "members.user": userId,
    })
      .sort({ createdAt: -1 })
      .lean();

    return res.json(workspaces);
  } catch (e) {
    console.error("Error fetching workspaces:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

// Get details of a single workspace (only if user is member/owner)
export async function getWorkspaceById(req, res) {
  try {
    const userId = req.userId;
    const { id } = req.params;

    const workspace = await Workspace.findById(id)
      .populate("owner", "name email lastActive")
      .populate("members.user", "name email lastActive")
      .lean();

    if (!workspace) {
      return res.status(404).json({ message: "Workspace not found" });
    }

    const isMember = (workspace.members || []).some(
      (m) => String(m.user?._id || m.user) === String(userId)
    );

    if (!isMember) {
      return res
        .status(403)
        .json({ message: "Not allowed to view workspace" });
    }

    const now = Date.now();

    let ownerData = null;
    if (workspace.owner) {
      const lastActive = workspace.owner.lastActive
        ? new Date(workspace.owner.lastActive).getTime()
        : 0;
      const isOnline =
        lastActive > 0 && now - lastActive < ONLINE_THRESHOLD_MS;

      ownerData = {
        _id: workspace.owner._id,
        name: workspace.owner.name,
        email: workspace.owner.email,
        isOnline,
      };
    }

    const members = (workspace.members || [])
      .map((m) => {
        const u = m.user;
        if (!u) return null;
        const lastActive = u.lastActive
          ? new Date(u.lastActive).getTime()
          : 0;
        const isOnline =
          lastActive > 0 && now - lastActive < ONLINE_THRESHOLD_MS;

        return {
          _id: u._id,
          name: u.name,
          email: u.email,
          role: m.role,
          isOnline,
        };
      })
      .filter(Boolean);

    return res.json({
      _id: workspace._id,
      name: workspace.name,
      description: workspace.description,
      owner: ownerData,
      members,
    });
  } catch (e) {
    console.error("Error fetching workspace:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

// Change a member's role (owner, editor, viewer) â€“ only owner can do this
export async function updateMemberRole(req, res) {
  try {
    const userId = req.userId;
    const { id, memberId } = req.params;
    const { role } = req.body;

    const allowedRoles = ["owner", "editor", "viewer"];
    if (!allowedRoles.includes(role)) {
      return res.status(400).json({ message: "Invalid role" });
    }

    const workspace = await Workspace.findById(id).populate("owner", "_id");
    if (!workspace) {
      return res.status(404).json({ message: "Workspace not found" });
    }

    if (String(workspace.owner._id) !== String(userId)) {
      return res
        .status(403)
        .json({ message: "Only owner can change member roles" });
    }

    const member = workspace.members.find(
      (m) => String(m.user) === String(memberId)
    );
    if (!member) {
      return res.status(404).json({ message: "Member not found in workspace" });
    }

    // Do not allow owner to make themselves non-owner using this endpoint
    if (
      String(workspace.owner._id) === String(memberId) &&
      role !== "owner"
    ) {
      return res.status(400).json({
        message:
          "To change owner, assign role 'owner' to another member first.",
      });
    }

    if (role === "owner") {
      // Transfer ownership: new owner gets owner role, old owner becomes editor
      workspace.members.forEach((m) => {
        if (String(m.user) === String(memberId)) {
          m.role = "owner";
        } else if (m.role === "owner") {
          m.role = "editor"; // demote previous owner
        }
      });
      workspace.owner = member.user;
    } else {
      member.role = role;
    }

    await workspace.save();

    return res.json({ message: "Member role updated" });
  } catch (e) {
    console.error("Error updating member role:", e);
    return res.status(500).json({ message: "Server error" });
  }
}

// Remove a member from workspace â€“ only owner, cannot remove owner
export async function removeMember(req, res) {
  try {
    const userId = req.userId;
    const { id, memberId } = req.params;

    const workspace = await Workspace.findById(id).populate("owner", "_id");
    if (!workspace) {
      return res.status(404).json({ message: "Workspace not found" });
    }

    if (String(workspace.owner._id) !== String(userId)) {
      return res
        .status(403)
        .json({ message: "Only owner can remove members" });
    }

    if (String(workspace.owner._id) === String(memberId)) {
      return res
        .status(400)
        .json({ message: "Owner cannot be removed from the workspace" });
    }

    const beforeCount = workspace.members.length;
    workspace.members = workspace.members.filter(
      (m) => String(m.user) !== String(memberId)
    );

    if (workspace.members.length === beforeCount) {
      return res
        .status(404)
        .json({ message: "Member not found in workspace" });
    }

    await workspace.save();

    return res.json({ message: "Member removed from workspace" });
  } catch (e) {
    console.error("Error removing member:", e);
    return res.status(500).json({ message: "Server error" });
  }
}


===== FILE: backend\src\middleware\authMiddleware.js =====
import jwt from "jsonwebtoken";
import User from "../models/User.js";

export function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;

  if (!authHeader) {
    return res.status(401).json({ message: "No token provided" });
  }

  const parts = authHeader.split(" ");
  if (parts.length !== 2 || parts[0] !== "Bearer") {
    return res.status(401).json({ message: "Invalid authorization format" });
  }

  const token = parts[1];

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.userId = decoded.id;

    // Update lastActive (fire and forget)
    User.findByIdAndUpdate(decoded.id, { lastActive: new Date() }).catch(
      () => {}
    );

    next();
  } catch (err) {
    return res.status(401).json({ message: "Invalid or expired token" });
  }
}


===== FILE: backend\src\models\Board.js =====
import mongoose from "mongoose";

const segmentSchema = new mongoose.Schema(
  {
    x0: Number,
    y0: Number,
    x1: Number,
    y1: Number,
    color: { type: String, default: "#000000" },
    width: { type: Number, default: 2 },
  },
  { _id: false }
);

const boardSchema = new mongoose.Schema(
  {
    workspace: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Workspace",
      required: true,
    },
    title: { type: String, default: "Untitled Board" },
    segments: { type: [segmentSchema], default: [] }, // saved state
  },
  { timestamps: true }
);

export default mongoose.model("Board", boardSchema);


===== FILE: backend\src\models\Invitation.js =====
// backend/src/models/Invitation.js
import mongoose from "mongoose";

const invitationSchema = new mongoose.Schema(
  {
    workspace: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Workspace",
      required: true,
    },
    invitedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    invitedUser: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    status: {
      type: String,
      enum: ["pending", "accepted", "rejected"],
      default: "pending",
    },
  },
  { timestamps: true }
);

export default mongoose.model("Invitation", invitationSchema);


===== FILE: backend\src\models\Message.js =====
// backend/src/models/Message.js
import mongoose from "mongoose";

const messageSchema = new mongoose.Schema(
  {
    workspace: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Workspace",
      required: true,
      index: true,
    },
    sender: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    text: { type: String, required: true, trim: true },
  },
  { timestamps: true }
);

// Helps quick recent-message queries per workspace
messageSchema.index({ workspace: 1, createdAt: -1 });

export default mongoose.model("Message", messageSchema);


===== FILE: backend\src\models\User.js =====
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true }, // hashed password
  lastActive: { type: Date, default: null },  // for online/offline status
});

export default mongoose.model("User", userSchema);


===== FILE: backend\src\models\Workspace.js =====
// backend/src/models/Workspace.js
import mongoose from "mongoose";

const memberSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    role: {
      type: String,
      enum: ["owner", "editor", "viewer"],
      default: "viewer",
    },
  },
  { _id: false }
);

const workspaceSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    description: { type: String },

    // Current owner (there can be only one)
    owner: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    // Members (including owner) with roles
    members: [memberSchema],
  },
  { timestamps: true }
);

export default mongoose.model("Workspace", workspaceSchema);


===== FILE: backend\src\routes\authRoutes.js =====
import express from "express";
import { register, login, updateMe } from "../controllers/authController.js";
import { authMiddleware } from "../middleware/authMiddleware.js";

const router = express.Router();

router.post("/register", register);
router.post("/login", login);


router.put("/me", authMiddleware, updateMe);

export default router;


===== FILE: backend\src\routes\boardRoutes.js =====
import express from "express";
import { authMiddleware } from "../middleware/authMiddleware.js";
import {
  createBoard,
  listBoards,
  getBoard,
  saveBoard,
} from "../controllers/boardController.js";

const router = express.Router();

router.post("/", authMiddleware, createBoard);
router.get("/workspace/:workspaceId", authMiddleware, listBoards);
router.get("/:boardId", authMiddleware, getBoard);
router.put("/:boardId/save", authMiddleware, saveBoard);

export default router;


===== FILE: backend\src\routes\chatRoutes.js =====
// backend/src/routes/chatRoutes.js
import express from "express";
import { authMiddleware } from "../middleware/authMiddleware.js";
import { getWorkspaceMessages } from "../controllers/chatController.js";

const router = express.Router();

// GET /api/workspaces/:id/messages
router.get("/:id/messages", authMiddleware, getWorkspaceMessages);

export default router;


===== FILE: backend\src\routes\invitationRoutes.js =====
// backend/src/routes/invitationRoutes.js
import express from "express";
import { authMiddleware } from "../middleware/authMiddleware.js";
import {
  getMyInvitations,
  acceptInvitation,
  rejectInvitation,
} from "../controllers/invitationController.js";

const router = express.Router();

// GET /api/invitations/my
router.get("/my", authMiddleware, getMyInvitations);

// POST /api/invitations/:id/accept
router.post("/:id/accept", authMiddleware, acceptInvitation);

// POST /api/invitations/:id/reject
router.post("/:id/reject", authMiddleware, rejectInvitation);

export default router;


===== FILE: backend\src\routes\workspaceRoutes.js =====
// backend/src/routes/workspaceRoutes.js
import express from "express";
import { authMiddleware } from "../middleware/authMiddleware.js";
import {
  createWorkspace,
  getMyWorkspaces,
  getWorkspaceById,
  inviteMembers,
  updateMemberRole,
  removeMember,
} from "../controllers/workspaceController.js";

const router = express.Router();

// POST /api/workspaces
router.post("/", authMiddleware, createWorkspace);

// POST /api/workspaces/:id/invite
router.post("/:id/invite", authMiddleware, inviteMembers);

// GET /api/workspaces/my
router.get("/my", authMiddleware, getMyWorkspaces);

// GET /api/workspaces/:id
router.get("/:id", authMiddleware, getWorkspaceById);

// PATCH /api/workspaces/:id/members/:memberId/role
router.patch(
  "/:id/members/:memberId/role",
  authMiddleware,
  updateMemberRole
);

// DELETE /api/workspaces/:id/members/:memberId
router.delete("/:id/members/:memberId", authMiddleware, removeMember);

export default router;


===== FILE: frontend\.gitignore =====
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
pnpm-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



===== FILE: frontend\eslint.config.js =====
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


===== FILE: frontend\index.html =====
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>frontend</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


===== FILE: frontend\package.json =====
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "lucide-react": "^0.556.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router": "^7.10.1",
    "react-router-dom": "^7.10.1",


    "socket.io-client": "^4.8.1"


  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.22",
    "daisyui": "^4.12.24",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.18",
    "vite": "^7.2.4"
  }
}


===== FILE: frontend\postcss.config.js =====
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


===== FILE: frontend\README.md =====
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.


===== FILE: frontend\tailwind.config.js =====
import daisyui from 'daisyui';

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [daisyui],
}

===== FILE: frontend\vite.config.js =====
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})


===== IMAGE FILE: frontend\public\vite.svg =====

===== FILE: frontend\src\App.jsx =====
import { Routes, Route } from "react-router-dom";
import LoginPage from "./pages/LoginPage";
import RegisterPage from "./pages/RegisterPage";
import DashboardPage from "./pages/DashboardPage";
import ProfilePage from "./pages/ProfilePage";
import CreateWorkspacePage from "./pages/CreateWorkspacePage";
import WorkspaceDetailsPage from "./pages/WorkspaceDetailsPage";
import NotificationsPage from "./pages/NotificationsPage";

import VoiceChatRoomPage from "./pages/VoiceChatRoomPage";

import WorkspaceBoardsPage from "./pages/WorkspaceBoardsPage";
import WhiteboardPage from "./pages/WhiteboardPage";


function App() {
  return (
    <div className="min-h-screen bg-base-200">
      <Routes>
        <Route path="/" element={<LoginPage />} />
        <Route path="/login" element={<LoginPage />} />
        <Route path="/register" element={<RegisterPage />} />
        <Route path="/dashboard" element={<DashboardPage />} />
        <Route path="/profile" element={<ProfilePage />} />
        <Route path="/workspaces/create" element={<CreateWorkspacePage />} />
        <Route path="/workspaces/:id" element={<WorkspaceDetailsPage />} />
        <Route path="/workspaces/:id/voice" element={<VoiceChatRoomPage />} />
        <Route path="/workspaces/:id/boards" element={<WorkspaceBoardsPage />} />
        <Route
          path="/workspaces/:id/boards/:boardId"
          element={<WhiteboardPage />}
        />
        <Route path="/notifications" element={<NotificationsPage />} />
      </Routes>
    </div>
  );
}

export default App;


===== FILE: frontend\src\index.css =====
@tailwind base;
@tailwind components;
@tailwind utilities;



===== FILE: frontend\src\main.jsx =====
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.jsx";
import { BrowserRouter } from "react-router-dom";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </StrictMode>
);


===== FILE: frontend\src\components\NavBar.jsx =====
// frontend/src/components/NavBar.jsx
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import { getUser, isLoggedIn } from "../lib/auth";
import api from "../lib/api";

function NavBar() {
  const user = getUser();
  const initial = user?.name?.[0]?.toUpperCase() || "U";
  const navigate = useNavigate();

  const [pendingCount, setPendingCount] = useState(0);

  useEffect(() => {
    const fetchInvites = async () => {
      if (!isLoggedIn()) return;
      const token = localStorage.getItem("token");
      if (!token) return;

      try {
        const res = await api.get("/invitations/my", {
          headers: { Authorization: `Bearer ${token}` },
        });
        setPendingCount(Array.isArray(res.data) ? res.data.length : 0);
      } catch {
        // keep silent for navbar
      }
    };

    fetchInvites();
  }, []);

  return (
    <div className="navbar bg-base-100 shadow-sm">
      <div className="max-w-6xl mx-auto flex w-full items-center justify-between px-4">
        {/* Left: Logo / Name */}
        <div className="flex items-center gap-2">
          <span
            className="text-xl font-bold tracking-tight cursor-pointer"
            onClick={() => navigate("/dashboard")}
          >
            Fusion<span className="text-primary">Board</span>
          </span>
        </div>

        {/* Right: Create workspace + notifications + profile icon */}
        <div className="flex items-center gap-4">
          <button
            className="btn btn-ghost btn-sm"
            onClick={() => navigate("/notifications")}
          >
            Notifications
            {pendingCount > 0 && (
              <span className="badge badge-secondary ml-1">
                {pendingCount}
              </span>
            )}
          </button>

          <button
            className="btn btn-primary btn-sm"
            onClick={() => navigate("/workspaces/create")}
          >
            Create workspace
          </button>

          {/* Round human icon (avatar placeholder) */}
          <div
            className="avatar cursor-pointer"
            onClick={() => navigate("/profile")}
            title="Profile"
          >
            <div className="w-10 rounded-full bg-neutral text-neutral-content flex items-center justify-center">
              <span className="text-lg font-semibold">{initial}</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default NavBar;


===== FILE: frontend\src\components\WorkspaceChat.jsx =====
// frontend/src/components/WorkspaceChat.jsx
import { useEffect, useMemo, useRef, useState } from "react";
import { io } from "socket.io-client";
import api from "../lib/api";
import { getUser } from "../lib/auth";

function formatTime(d) {
  try {
    return new Date(d).toLocaleString();
  } catch {
    return "";
  }
}

export default function WorkspaceChat({ workspaceId }) {
  const me = getUser();
  const token = useMemo(() => localStorage.getItem("token"), []);
  const [messages, setMessages] = useState([]);
  const [text, setText] = useState("");
  const [status, setStatus] = useState("connecting...");
  const bottomRef = useRef(null);

  // Load previous messages (persistent)
  useEffect(() => {
    const load = async () => {
      if (!token) return;
      try {
        const res = await api.get(`/workspaces/${workspaceId}/messages?limit=80`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        setMessages(Array.isArray(res.data) ? res.data : []);
      } catch {
        // If not allowed / error, keep quiet
      }
    };
    load();
  }, [workspaceId, token]);

  // Realtime socket
  useEffect(() => {
    if (!token) return;

    const socket = io("http://localhost:5001", {
      auth: { token },
    });

    socket.on("connect", () => setStatus("connected"));
    socket.on("disconnect", () => setStatus("disconnected"));

    socket.emit("workspace:join", { workspaceId }, (ack) => {
      if (!ack?.ok) {
        setStatus(ack?.message || "join failed");
      }
    });

    socket.on("chat:new", (msg) => {
      // Only accept messages for this workspace (extra safety)
      if (String(msg.workspace) !== String(workspaceId)) return;
      setMessages((prev) => [...prev, msg]);
    });

    return () => {
      socket.disconnect();
    };
  }, [workspaceId, token]);

  // Auto-scroll to latest
  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const send = async (e) => {
    e.preventDefault();
    const clean = text.trim();
    if (!clean) return;

    // Send via socket (faster). If socket is down, we just do nothing here.
    // (Simple version)
    const socket = io("http://localhost:5001", { auth: { token } });
    socket.emit("chat:send", { workspaceId, text: clean }, () => {
      socket.disconnect();
    });

    setText("");
  };

  return (
    <div className="card bg-base-100 shadow-md">
      <div className="card-body">
        <div className="flex items-center justify-between">
          <h2 className="card-title text-base">Workspace Chat</h2>
          <span className="text-xs text-neutral-500">{status}</span>
        </div>

        <div className="border border-base-200 rounded-lg p-3 h-72 overflow-y-auto bg-base-200">
          {messages.length === 0 ? (
            <div className="text-sm text-neutral-500">
              No messages yet. Say hi ðŸ‘‹
            </div>
          ) : (
            <div className="space-y-2">
              {messages.map((m) => {
                const mine = me?.id && m.sender?._id === me.id;
                return (
                  <div
                    key={m._id}
                    className={`chat ${mine ? "chat-end" : "chat-start"}`}
                  >
                    <div className="chat-header text-xs opacity-70">
                      {m.sender?.name || "Unknown"} â€¢ {formatTime(m.createdAt)}
                    </div>
                    <div className="chat-bubble">{m.text}</div>
                  </div>
                );
              })}
              <div ref={bottomRef} />
            </div>
          )}
        </div>

        <form onSubmit={send} className="flex gap-2 mt-3">
          <input
            className="input input-bordered w-full"
            value={text}
            onChange={(e) => setText(e.target.value)}
            placeholder="Type a message..."
          />
          <button className="btn btn-primary" type="submit">
            Send
          </button>
        </form>

        <p className="text-xs text-neutral-500 mt-1">
          Messages are saved in MongoDB. Members can read old chat anytime.
        </p>
      </div>
    </div>
  );
}


===== FILE: frontend\src\lib\api.js =====
import axios from "axios";

export default axios.create({
  baseURL: "http://localhost:5001/api"
});


===== FILE: frontend\src\lib\auth.js =====
// Save token + user info
export function saveAuth(token, user) {
  localStorage.setItem("token", token);
  localStorage.setItem("user", JSON.stringify(user));
}

// Get current user object or null
export function getUser() {
  const raw = localStorage.getItem("user");
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

// Simple logged-in check
export function isLoggedIn() {
  return !!localStorage.getItem("token");
}

// Clear auth on logout
export function clearAuth() {
  localStorage.removeItem("token");
  localStorage.removeItem("user");
}


===== FILE: frontend\src\pages\CreateWorkspacePage.jsx =====
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import NavBar from "../components/NavBar";
import api from "../lib/api";
import { isLoggedIn } from "../lib/auth";

function CreateWorkspacePage() {
  const navigate = useNavigate();

  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [memberEmailsText, setMemberEmailsText] = useState("");
  const [error, setError] = useState("");
  const [message, setMessage] = useState("");
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!isLoggedIn()) {
      navigate("/login");
    }
  }, [navigate]);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setMessage("");

    const token = localStorage.getItem("token");
    if (!token) {
      setError("Not authenticated.");
      return;
    }

    const memberEmails = memberEmailsText
      .split(",")
      .map((e) => e.trim())
      .filter((e) => e.length > 0);

    setLoading(true);
    try {
      await api.post(
        "/workspaces",
        { name, description, memberEmails },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      setMessage(
        "Workspace created and invitations sent to registered users (by email)."
      );
      setTimeout(() => {
        navigate("/dashboard");
      }, 800);
    } catch (err) {
      const msg =
        err?.response?.data?.message || "Failed to create workspace.";
      setError(msg);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-base-200 flex flex-col">
      <NavBar />

      <main className="flex-1">
        <div className="max-w-xl mx-auto px-4 py-6">
          <h1 className="text-2xl font-bold mb-2">Create Workspace</h1>
          <p className="text-sm text-neutral-500 mb-4">
            Enter a name, description, and the emails of members you want to
            invite.
          </p>

          {error && (
            <div className="alert alert-error py-2 text-sm mb-3">
              <span>{error}</span>
            </div>
          )}
          {message && (
            <div className="alert alert-success py-2 text-sm mb-3">
              <span>{message}</span>
            </div>
          )}

          <div className="card bg-base-100 shadow-md">
            <div className="card-body">
              <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                  <label className="label">
                    <span className="label-text font-semibold">Name</span>
                  </label>
                  <input
                    type="text"
                    className="input input-bordered w-full"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    required
                    placeholder="Team Design Board"
                  />
                </div>

                <div>
                  <label className="label">
                    <span className="label-text font-semibold">
                      Description
                    </span>
                  </label>
                  <textarea
                    className="textarea textarea-bordered w-full"
                    rows={3}
                    value={description}
                    onChange={(e) => setDescription(e.target.value)}
                    placeholder="Short description of this workspace..."
                  />
                </div>

                <div>
                  <label className="label">
                    <span className="label-text font-semibold">
                      Member emails
                    </span>
                  </label>
                  <textarea
                    className="textarea textarea-bordered w-full"
                    rows={3}
                    value={memberEmailsText}
                    onChange={(e) => setMemberEmailsText(e.target.value)}
                    placeholder="example1@mail.com, example2@mail.com"
                  />
                  <p className="text-xs text-neutral-500 mt-1">
                    Separate emails with commas. Invitations are only sent to
                    users who already registered in the system.
                  </p>
                </div>

                <div className="pt-2">
                  <button
                    type="submit"
                    className={`btn btn-primary w-full ${
                      loading ? "btn-disabled" : ""
                    }`}
                    disabled={loading}
                  >
                    {loading ? "Creating..." : "Create workspace"}
                  </button>
                </div>
              </form>
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}

export default CreateWorkspacePage;


===== FILE: frontend\src\pages\DashboardPage.jsx =====
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import { getUser, isLoggedIn, clearAuth } from "../lib/auth";
import NavBar from "../components/NavBar";
import api from "../lib/api";

function DashboardPage() {
  const navigate = useNavigate();
  const user = getUser();

  const [workspaces, setWorkspaces] = useState([]);
  const [loadingWorkspaces, setLoadingWorkspaces] = useState(true);
  const [error, setError] = useState("");

  // If not logged in, redirect to login
  useEffect(() => {
    if (!isLoggedIn()) {
      navigate("/login");
    }
  }, [navigate]);

  useEffect(() => {
    const fetchWorkspaces = async () => {
      const token = localStorage.getItem("token");
      if (!token) {
        setLoadingWorkspaces(false);
        return;
      }

      setError("");
      setLoadingWorkspaces(true);
      try {
        const res = await api.get("/workspaces/my", {
          headers: { Authorization: `Bearer ${token}` },
        });
        setWorkspaces(Array.isArray(res.data) ? res.data : []);
      } catch (err) {
        setError("Failed to load workspaces.");
      } finally {
        setLoadingWorkspaces(false);
      }
    };

    fetchWorkspaces();
  }, []);

  const handleLogout = () => {
    clearAuth();
    navigate("/login");
  };

  return (
    <div className="min-h-screen bg-base-200 flex flex-col">
      <NavBar />

      <main className="flex-1">
        <div className="max-w-6xl mx-auto px-4 py-6">
          <div className="flex items-center justify-between mb-6">
            <div>
              <h1 className="text-2xl font-bold">Dashboard</h1>
              <p className="text-sm text-neutral-500">
                {user
                  ? `Logged in as ${user.name} (${user.email})`
                  : "Loading user..."}
              </p>
            </div>

            <button onClick={handleLogout} className="btn btn-ghost btn-sm">
              Logout
            </button>
          </div>

          {error && (
            <div className="alert alert-error mb-4 py-2 text-sm">
              <span>{error}</span>
            </div>
          )}

          <section>
            <h2 className="text-lg font-semibold mb-3">My Workspaces</h2>

            {loadingWorkspaces ? (
              <div className="rounded-box border border-base-300 p-6 bg-base-100 text-sm text-neutral-500">
                Loading workspaces...
              </div>
            ) : workspaces.length === 0 ? (
              <div className="rounded-box border border-dashed border-base-300 p-6 text-center text-sm text-neutral-500 bg-base-100">
                No workspaces yet.
                <br />
                Use the{" "}
                <span className="font-semibold">Create workspace</span> button
                in the top right to add one later.
              </div>
            ) : (
              <div className="grid gap-4 md:grid-cols-2">
                {workspaces.map((ws) => (
                  <div
                    key={ws._id}
                    className="card bg-base-100 shadow-sm cursor-pointer hover:shadow-md transition"
                    onClick={() => navigate(`/workspaces/${ws._id}`)}
                  >
                    <div className="card-body">
                      <h3 className="card-title text-base">{ws.name}</h3>
                      {ws.description && (
                        <p className="text-sm text-neutral-600 line-clamp-2">
                          {ws.description}
                        </p>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </section>
        </div>
      </main>
    </div>
  );
}

export default DashboardPage;


===== FILE: frontend\src\pages\LoginPage.jsx =====
import { useState, useEffect } from "react";
import { useNavigate, Link } from "react-router-dom";
import api from "../lib/api";
import { saveAuth, isLoggedIn } from "../lib/auth";

function LoginPage() {
  const navigate = useNavigate();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  // If already logged in, go to dashboard
  useEffect(() => {
    if (isLoggedIn()) {
      navigate("/dashboard");
    }
  }, [navigate]);

  const handleLogin = async (e) => {
    e.preventDefault();
    setError("");

    try {
      const res = await api.post("/auth/login", { email, password });

      saveAuth(res.data.token, res.data.user);

      // Go to dashboard
      navigate("/dashboard");
    } catch (err) {
      setError("Login failed. Check email or password.");
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="card w-full max-w-sm bg-base-100 shadow-xl">
        <div className="card-body">
          <h2 className="card-title justify-center mb-4">Login</h2>

          {error && (
            <div className="alert alert-error py-1 text-sm mb-2">
              <span>{error}</span>
            </div>
          )}

          <form onSubmit={handleLogin} className="space-y-3">
            <div className="form-control">
              <label className="label">
                <span className="label-text">Email</span>
              </label>
              <input
                type="email"
                className="input input-bordered"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                placeholder="you@example.com"
              />
            </div>

            <div className="form-control">
              <label className="label">
                <span className="label-text">Password</span>
              </label>
              <input
                type="password"
                className="input input-bordered"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
              />
            </div>

            <button type="submit" className="btn btn-primary w-full mt-2">
              Login
            </button>
          </form>

          <p className="text-center text-sm mt-4">
            New here?{" "}
            <Link to="/register" className="link link-primary">
              Register
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}

export default LoginPage;


===== FILE: frontend\src\pages\NotificationsPage.jsx =====
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import NavBar from "../components/NavBar";
import api from "../lib/api";
import { isLoggedIn } from "../lib/auth";

function NotificationsPage() {
  const navigate = useNavigate();

  const [invitations, setInvitations] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [message, setMessage] = useState("");

  useEffect(() => {
    const token = localStorage.getItem("token");
    if (!isLoggedIn() || !token) {
      navigate("/login");
      return;
    }

    const fetchInvites = async () => {
      setError("");
      setLoading(true);
      try {
        const res = await api.get("/invitations/my", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        setInvitations(Array.isArray(res.data) ? res.data : []);
      } catch (err) {
        const msg =
          err?.response?.data?.message || "Failed to load invitations.";
        setError(msg);
      } finally {
        setLoading(false);
      }
    };

    fetchInvites();
  }, [navigate]);

  const handleAction = async (id, action) => {
    setError("");
    setMessage("");

    const token = localStorage.getItem("token");
    if (!token) {
      setError("Not authenticated.");
      return;
    }

    try {
      await api.post(
        `/invitations/${id}/${action}`,
        {},
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      setMessage(
        action === "accept"
          ? "Invitation accepted."
          : "Invitation rejected."
      );

      // Remove from list
      setInvitations((prev) => prev.filter((inv) => inv._id !== id));
    } catch (err) {
      const msg =
        err?.response?.data?.message || "Failed to update invitation.";
      setError(msg);
    }
  };

  return (
    <div className="min-h-screen bg-base-200 flex flex-col">
      <NavBar />

      <main className="flex-1">
        <div className="max-w-3xl mx-auto px-4 py-6">
          <h1 className="text-2xl font-bold mb-2">Notifications</h1>
          <p className="text-sm text-neutral-500 mb-4">
            Here you can accept or reject workspace invitations.
          </p>

          {error && (
            <div className="alert alert-error py-2 text-sm mb-3">
              <span>{error}</span>
            </div>
          )}
          {message && (
            <div className="alert alert-success py-2 text-sm mb-3">
              <span>{message}</span>
            </div>
          )}

          {loading ? (
            <div className="rounded-box border border-base-300 p-6 bg-base-100 text-sm text-neutral-500">
              Loading invitations...
            </div>
          ) : invitations.length === 0 ? (
            <div className="rounded-box border border-base-300 p-6 bg-base-100 text-sm text-neutral-500">
              You have no pending invitations.
            </div>
          ) : (
            <div className="space-y-3">
              {invitations.map((inv) => (
                <div
                  key={inv._id}
                  className="card bg-base-100 shadow-sm border border-base-200"
                >
                  <div className="card-body">
                    <h2 className="card-title text-base mb-1">
                      Workspace: {inv.workspace?.name || "Unknown"}
                    </h2>
                    <p className="text-sm text-neutral-600 mb-2">
                      Invited by{" "}
                      <span className="font-medium">
                        {inv.invitedBy?.name || "Someone"}
                      </span>{" "}
                      ({inv.invitedBy?.email || "no email"})
                    </p>

                    <div className="flex gap-2">
                      <button
                        className="btn btn-sm btn-primary"
                        onClick={() => handleAction(inv._id, "accept")}
                      >
                        Accept
                      </button>
                      <button
                        className="btn btn-sm btn-ghost"
                        onClick={() => handleAction(inv._id, "reject")}
                      >
                        Reject
                      </button>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </main>
    </div>
  );
}

export default NotificationsPage;


===== FILE: frontend\src\pages\ProfilePage.jsx =====
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import NavBar from "../components/NavBar";
import api from "../lib/api";
import { getUser, isLoggedIn, saveAuth, clearAuth } from "../lib/auth";

function ProfilePage() {
  const navigate = useNavigate();
  const storedUser = getUser();

  const [name, setName] = useState(storedUser?.name || "");
  const [email, setEmail] = useState(storedUser?.email || "");
  const [message, setMessage] = useState("");
  const [error, setError] = useState("");

  // Redirect if not logged in
  useEffect(() => {
    if (!isLoggedIn()) {
      navigate("/login");
    }
  }, [navigate]);

  const handleLogout = () => {
    clearAuth();
    navigate("/login");
  };

  const handleUpdate = async (e) => {
    e.preventDefault();
    setError("");
    setMessage("");

    try {
      const token = localStorage.getItem("token");
      if (!token) {
        setError("Not authenticated.");
        return;
      }

      const res = await api.put(
        "/auth/me",
        { name, email },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      // Update localStorage user with new data
      saveAuth(token, res.data.user);
      setMessage("Profile updated successfully.");
    } catch (err) {
      const msg =
        err?.response?.data?.message || "Failed to update profile.";
      setError(msg);
    }
  };

  const idText = storedUser?.id || "N/A";

  return (
    <div className="min-h-screen bg-base-200 flex flex-col">
      <NavBar />

      <main className="flex-1">
        <div className="max-w-3xl mx-auto px-4 py-6">
          <div className="flex items-center justify-between mb-6">
            <div>
              <h1 className="text-2xl font-bold">Profile</h1>
              <p className="text-sm text-neutral-500">
                View and update your account details.
              </p>
            </div>

            <button
              onClick={handleLogout}
              className="btn btn-ghost btn-sm"
            >
              Logout
            </button>
          </div>

          <div className="card bg-base-100 shadow-xl">
            <div className="card-body">
              {error && (
                <div className="alert alert-error py-2 text-sm mb-2">
                  <span>{error}</span>
                </div>
              )}
              {message && (
                <div className="alert alert-success py-2 text-sm mb-2">
                  <span>{message}</span>
                </div>
              )}

              <form onSubmit={handleUpdate} className="space-y-4">
                <div>
                  <label className="label">
                    <span className="label-text font-semibold">
                      User ID
                    </span>
                  </label>
                  <input
                    type="text"
                    value={idText}
                    disabled
                    className="input input-bordered w-full bg-base-200"
                  />
                </div>

                <div>
                  <label className="label">
                    <span className="label-text font-semibold">
                      Name
                    </span>
                  </label>
                  <input
                    type="text"
                    className="input input-bordered w-full"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    required
                  />
                </div>

                <div>
                  <label className="label">
                    <span className="label-text font-semibold">
                      Email
                    </span>
                  </label>
                  <input
                    type="email"
                    className="input input-bordered w-full"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    required
                  />
                </div>

                <div className="pt-2">
                  <button type="submit" className="btn btn-primary">
                    Save changes
                  </button>
                </div>
              </form>
            </div>
          </div>

        </div>
      </main>
    </div>
  );
}

export default ProfilePage;


===== FILE: frontend\src\pages\RegisterPage.jsx =====
import { useState } from "react";
import { useNavigate, Link } from "react-router-dom";
import api from "../lib/api";

function RegisterPage() {
  const navigate = useNavigate();
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  const handleRegister = async (e) => {
    e.preventDefault();
    setError("");

    try {
      await api.post("/auth/register", { name, email, password });
      // After register, go to login
      navigate("/login");
    } catch (err) {
      setError("Registration failed. Try another email.");
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="card w-full max-w-sm bg-base-100 shadow-xl">
        <div className="card-body">
          <h2 className="card-title justify-center mb-4">Register</h2>

          {error && (
            <div className="alert alert-error py-1 text-sm mb-2">
              <span>{error}</span>
            </div>
          )}

          <form onSubmit={handleRegister} className="space-y-3">
            <div className="form-control">
              <label className="label">
                <span className="label-text">Name</span>
              </label>
              <input
                type="text"
                className="input input-bordered"
                value={name}
                onChange={(e) => setName(e.target.value)}
                required
                placeholder="Your name"
              />
            </div>

            <div className="form-control">
              <label className="label">
                <span className="label-text">Email</span>
              </label>
              <input
                type="email"
                className="input input-bordered"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                placeholder="you@example.com"
              />
            </div>

            <div className="form-control">
              <label className="label">
                <span className="label-text">Password</span>
              </label>
              <input
                type="password"
                className="input input-bordered"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
              />
            </div>

            <button type="submit" className="btn btn-primary w-full mt-2">
              Register
            </button>
          </form>

          <p className="text-center text-sm mt-4">
            Already have an account?{" "}
            <Link to="/login" className="link link-primary">
              Back to Login
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}

export default RegisterPage;


===== FILE: frontend\src\pages\VoiceChatRoomPage.jsx =====
import { useMemo, useRef, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import { io } from "socket.io-client";
import NavBar from "../components/NavBar";
import { getUser, isLoggedIn } from "../lib/auth";

const SIGNAL_URL = "http://localhost:5001";

const RTC_CONFIG = {
  iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
};

function VoiceChatRoomPage() {
  const { id: roomId } = useParams();
  const navigate = useNavigate();
  const me = getUser();

  const [status, setStatus] = useState("idle");
  const [error, setError] = useState("");
  const [isMuted, setIsMuted] = useState(false);
  const [participants, setParticipants] = useState([]); // [{ peerId, name }]

  const socket = useRef(null);
  const localStream = useRef(null);
  const pcs = useRef(new Map()); // peerId -> RTCPeerConnection
  const pendingIce = useRef(new Map()); // peerId -> RTCIceCandidate[]
  const makingOffer = useRef(new Map()); // peerId -> boolean

  const token = useMemo(() => {
    if (typeof window === "undefined") return null;
    return localStorage.getItem("token");
  }, []);

  const ensurePendingIceList = (peerId) => {
    if (!pendingIce.current.has(peerId)) pendingIce.current.set(peerId, []);
    return pendingIce.current.get(peerId);
  };

  const setMakingOffer = (peerId, v) => {
    makingOffer.current.set(peerId, v);
  };

  const getMakingOffer = (peerId) => {
    return makingOffer.current.get(peerId) === true;
  };

  const cleanupPeer = (peerId) => {
    const pc = pcs.current.get(peerId);
    if (pc) {
      try {
        pc.onicecandidate = null;
        pc.ontrack = null;
        pc.onconnectionstatechange = null;
        pc.close();
      } catch {}
      pcs.current.delete(peerId);
    }
    pendingIce.current.delete(peerId);
    makingOffer.current.delete(peerId);

    const audioEl = document.getElementById(`audio-${peerId}`);
    if (audioEl) audioEl.remove();
  };

  const createPeerConnection = (peerId) => {
    const pc = new RTCPeerConnection(RTC_CONFIG);

    // Add local audio tracks
    const stream = localStream.current;
    if (stream) {
      for (const track of stream.getTracks()) pc.addTrack(track, stream);
    }

    // Receive remote audio
    pc.ontrack = (event) => {
      const [remoteStream] = event.streams;
      if (!remoteStream) return;

      const elId = `audio-${peerId}`;
      let audioEl = document.getElementById(elId);

      if (!audioEl) {
        audioEl = document.createElement("audio");
        audioEl.id = elId;
        audioEl.autoplay = true;
        audioEl.playsInline = true;
        audioEl.controls = true;
        audioEl.className = "w-full mt-2";
        document.getElementById("remote-audio-container")?.appendChild(audioEl);
      }

      audioEl.srcObject = remoteStream;
      audioEl.play().catch(() => {});
    };

    // ICE out
    pc.onicecandidate = (event) => {
      if (event.candidate && socket.current) {
        socket.current.emit("voice:signal", {
          to: peerId,
          data: { type: "ice", candidate: event.candidate },
        });
      }
    };

    pc.onconnectionstatechange = () => {
      const st = pc.connectionState;
      if (st === "failed" || st === "disconnected" || st === "closed") {
        cleanupPeer(peerId);
      }
    };

    pcs.current.set(peerId, pc);
    return pc;
  };

  const ensurePC = (peerId) => pcs.current.get(peerId) || createPeerConnection(peerId);

  const flushPendingIce = async (peerId) => {
    const pc = pcs.current.get(peerId);
    if (!pc || !pc.remoteDescription) return;

    const list = pendingIce.current.get(peerId);
    if (!list || list.length === 0) return;

    while (list.length) {
      const cand = list.shift();
      try {
        await pc.addIceCandidate(cand);
      } catch {}
    }
  };

  // Deterministic offerer: only one side offers (prevents "glare")
  const iShouldOffer = (peerId) => {
    const myId = socket.current?.id;
    if (!myId) return false;
    return myId < peerId; // stable ordering
  };

  const makeOfferTo = async (peerId) => {
    const pc = ensurePC(peerId);

    if (!iShouldOffer(peerId)) return;
    if (pc.signalingState !== "stable") return;
    if (pc.localDescription || pc.remoteDescription) return; // already negotiated once

    try {
      setMakingOffer(peerId, true);

      const offer = await pc.createOffer({
        offerToReceiveAudio: true,
        offerToReceiveVideo: false,
      });
      await pc.setLocalDescription(offer);

      socket.current.emit("voice:signal", {
        to: peerId,
        data: { type: "offer", sdp: pc.localDescription },
      });
    } finally {
      setMakingOffer(peerId, false);
    }
  };

  const joinRoom = async () => {
    setError("");

    if (!isLoggedIn() || !token) {
      navigate("/login");
      return;
    }

    setStatus("connecting");

    try {
      // get mic
      localStream.current = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
        video: false,
      });

      socket.current = io(SIGNAL_URL, {
        auth: { token },
        transports: ["websocket"],
      });

      socket.current.on("connect_error", (e) => {
        setStatus("error");
        setError(e?.message || "Socket connection failed");
      });

      socket.current.on("connect", () => {
        socket.current.emit("voice:join", { roomId });
      });

      // Always update list (server sends full list)
      socket.current.on("voice:participants:update", async ({ participants }) => {
        const list = Array.isArray(participants) ? participants : [];
        setParticipants(list);

        const myId = socket.current?.id;
        const others = myId ? list.filter((p) => p.peerId !== myId) : list;

        // Ensure PCs exist
        for (const p of others) ensurePC(p.peerId);

        setStatus("connected");

        // Only the deterministic offerer makes offers
        for (const p of others) {
          await makeOfferTo(p.peerId);
        }
      });

      socket.current.on("voice:peer-left", ({ peerId }) => {
        cleanupPeer(peerId);
      });

      socket.current.on("voice:signal", async ({ from, data }) => {
        const pc = ensurePC(from);

        try {
          if (data?.type === "offer") {
            // If we are currently making an offer, ignore glare by answering only if we are NOT the offerer
            // With deterministic rule, only one side should offer anyway.
            if (getMakingOffer(from) && iShouldOffer(from)) return;

            await pc.setRemoteDescription(data.sdp);
            await flushPendingIce(from);

            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            socket.current.emit("voice:signal", {
              to: from,
              data: { type: "answer", sdp: pc.localDescription },
            });
          } else if (data?.type === "answer") {
            await pc.setRemoteDescription(data.sdp);
            await flushPendingIce(from);
          } else if (data?.type === "ice" && data?.candidate) {
            if (!pc.remoteDescription) {
              ensurePendingIceList(from).push(data.candidate);
            } else {
              await pc.addIceCandidate(data.candidate);
            }
          }
        } catch {
          // keep silent
        }
      });
    } catch (e) {
      setStatus("error");
      setError(e?.message || "Could not start voice chat. Check mic permission.");
    }
  };

  const leaveRoom = () => {
    setError("");

    try {
      if (socket.current) {
        socket.current.emit("voice:leave", { roomId });
        socket.current.disconnect();
      }
    } catch {}
    socket.current = null;

    for (const [peerId, pc] of pcs.current.entries()) {
      try {
        pc.close();
      } catch {}
      pcs.current.delete(peerId);

      const audioEl = document.getElementById(`audio-${peerId}`);
      if (audioEl) audioEl.remove();
    }

    pendingIce.current.clear();
    makingOffer.current.clear();

    if (localStream.current) {
      for (const t of localStream.current.getTracks()) t.stop();
      localStream.current = null;
    }

    setParticipants([]);
    setIsMuted(false);
    setStatus("idle");
  };

  const toggleMute = () => {
    const stream = localStream.current;
    if (!stream) return;
    const track = stream.getAudioTracks()[0];
    if (!track) return;

    const next = !isMuted;
    track.enabled = !next;
    setIsMuted(next);
  };

  const myLabel = (peerId) => {
    if (!socket.current?.id) return "";
    return peerId === socket.current.id ? " (you)" : "";
  };

  return (
    <div className="min-h-screen bg-base-200 flex flex-col">
      <NavBar />

      <main className="flex-1">
        <div className="max-w-3xl mx-auto px-4 py-6">
          <div className="mb-5">
            <h1 className="text-2xl font-bold">Voice Chat Room</h1>
            <p className="text-sm text-neutral-500">
              Room ID: <span className="font-mono">{roomId}</span>
            </p>
            {me?.name && (
              <p className="text-xs text-neutral-500">
                Logged in as: <span className="font-semibold">{me.name}</span>
              </p>
            )}
          </div>

          {error && (
            <div className="alert alert-error py-2 text-sm mb-3">
              <span>{error}</span>
            </div>
          )}

          <div className="card bg-base-100 shadow-md">
            <div className="card-body space-y-3">
              <div className="flex items-center justify-between">
                <div className="text-sm">
                  Status: <span className="font-semibold">{status}</span>
                </div>
                <div className="text-sm">
                  People in call:{" "}
                  <span className="font-semibold">{participants.length}</span>
                </div>
              </div>

              <div className="flex flex-wrap gap-2">
                {status === "idle" || status === "error" ? (
                  <button className="btn btn-primary btn-sm" onClick={joinRoom}>
                    Join Voice Room
                  </button>
                ) : (
                  <button className="btn btn-ghost btn-sm" onClick={leaveRoom}>
                    Leave Room
                  </button>
                )}

                <button
                  className={`btn btn-sm ${isMuted ? "btn-warning" : "btn-outline"}`}
                  onClick={toggleMute}
                  disabled={status !== "connected"}
                >
                  {isMuted ? "Unmute" : "Mute"}
                </button>

                <button
                  className="btn btn-sm btn-outline"
                  onClick={() => navigate(`/workspaces/${roomId}`)}
                >
                  Back to Workspace
                </button>
              </div>

              <div className="divider" />

              <div>
                <h2 className="font-semibold mb-2">Participants</h2>
                {participants.length === 0 ? (
                  <p className="text-sm text-neutral-500">No one in the call yet.</p>
                ) : (
                  <ul className="text-sm space-y-1">
                    {participants.map((p) => (
                      <li key={p.peerId} className="flex items-center justify-between">
                        <span className="font-medium">
                          {p.name || "Unknown"}
                          <span className="text-neutral-500">{myLabel(p.peerId)}</span>
                        </span>
                        <span className="text-xs font-mono text-neutral-500">
                          {p.peerId.slice(0, 6)}...
                        </span>
                      </li>
                    ))}
                  </ul>
                )}
              </div>

              <div className="divider" />

              <div>
                <h2 className="font-semibold mb-2">Remote Audio</h2>
                <div id="remote-audio-container" className="space-y-2" />
                <p className="text-xs text-neutral-500 mt-2">
                  If autoplay is blocked, click Play on the audio controls above.
                </p>
              </div>
            </div>
          </div>

          <div className="mt-3 text-xs text-neutral-500">
            Same PC tip: use headphones to avoid echo/feedback.
          </div>
        </div>
      </main>
    </div>
  );
}

export default VoiceChatRoomPage;


===== FILE: frontend\src\pages\WhiteboardPage.jsx =====
import { useEffect, useRef, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import NavBar from "../components/NavBar";
import { getUser, isLoggedIn } from "../lib/auth";
import api from "../lib/api";
import { io } from "socket.io-client";

function WhiteboardPage() {
  const navigate = useNavigate();
  const { id, boardId } = useParams();

  const me = getUser(); // { id, name, email }

  const canvasRef = useRef(null);
  const ctxRef = useRef(null);
  const socketRef = useRef(null);

  const drawingRef = useRef(false);
  const lastPointRef = useRef({ x: 0, y: 0 });

  const segmentsRef = useRef([]);
  const [statusMsg, setStatusMsg] = useState("");

  const [color, setColor] = useState("#000000");
  const [width, setWidth] = useState(2);
  const [tool, setTool] = useState("pen"); // "pen" | "eraser"

  // live cursors: { [userId]: { name, color, x, y, ts } }
  const [cursors, setCursors] = useState({});
  const lastCursorEmitRef = useRef(0);

  useEffect(() => {
    if (!isLoggedIn()) navigate("/login");
  }, [navigate]);

  const fillWhiteBackground = () => {
    const canvas = canvasRef.current;
    const ctx = ctxRef.current;
    if (!canvas || !ctx) return;
    ctx.save();
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  };

  const drawSegment = (seg) => {
    const ctx = ctxRef.current;
    if (!ctx || !seg) return;

    ctx.strokeStyle = seg.color || "#000000";
    ctx.lineWidth = seg.width || 2;

    ctx.beginPath();
    ctx.moveTo(seg.x0, seg.y0);
    ctx.lineTo(seg.x1, seg.y1);
    ctx.stroke();
  };

  const redrawAll = () => {
    const canvas = canvasRef.current;
    const ctx = ctxRef.current;
    if (!canvas || !ctx) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    fillWhiteBackground();

    for (const seg of segmentsRef.current) drawSegment(seg);
  };

  const resizeCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const parent = canvas.parentElement;
    const w = parent ? parent.clientWidth : 900;
    const h = 520;

    canvas.width = w;
    canvas.height = h;

    const ctx = canvas.getContext("2d");
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctxRef.current = ctx;

    redrawAll();
  };

  const getCanvasPoint = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    return {
      x: clientX - rect.left,
      y: clientY - rect.top,
    };
  };

  const loadBoard = async () => {
    const token = localStorage.getItem("token");
    if (!token) return;

    setStatusMsg("Loading board...");
    try {
      const res = await api.get(`/boards/${boardId}`, {
        headers: { Authorization: `Bearer ${token}` },
      });

      const segments = Array.isArray(res.data.segments) ? res.data.segments : [];
      segmentsRef.current = segments;

      redrawAll();
      setStatusMsg("");
    } catch (e) {
      setStatusMsg(e?.response?.data?.message || "Failed to load board.");
    }
  };

  useEffect(() => {
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    const socket = io("http://localhost:5001", {
      transports: ["websocket", "polling"],
      reconnection: true,
      reconnectionAttempts: 10,
      reconnectionDelay: 300,
    });
    socketRef.current = socket;

    socket.on("connect", () => {
      socket.emit("joinBoard", {
        boardId,
        user: { id: me?.id, name: me?.name || "User" },
      });
    });

    socket.on("draw", (segment) => {
      segmentsRef.current.push(segment);
      drawSegment(segment);
    });

    socket.on("saved", () => {
      setStatusMsg("Autosaved âœ…");
      setTimeout(() => setStatusMsg(""), 700);
    });

    // clear from server
    socket.on("cleared", () => {
      segmentsRef.current = [];
      redrawAll();
      setStatusMsg("Cleared âœ…");
      setTimeout(() => setStatusMsg(""), 700);
    });

    // cursor events
    socket.on("cursorJoin", ({ userId, name, color }) => {
      setCursors((prev) => ({
        ...prev,
        [userId]: prev[userId] || { name, color, x: 0, y: 0, ts: Date.now() },
      }));
    });

    socket.on("cursorMove", ({ userId, name, color, x, y }) => {
      setCursors((prev) => ({
        ...prev,
        [userId]: { name, color, x, y, ts: Date.now() },
      }));
    });

    socket.on("cursorLeave", ({ userId }) => {
      setCursors((prev) => {
        const copy = { ...prev };
        delete copy[userId];
        return copy;
      });
    });

    loadBoard();

    return () => {
      window.removeEventListener("resize", resizeCanvas);
      socket.emit("cursorLeave", { boardId });
      socket.off("connect");
      socket.off("draw");
      socket.off("saved");
      socket.off("cleared");
      socket.off("cursorJoin");
      socket.off("cursorMove");
      socket.off("cursorLeave");
      socket.close();
      socketRef.current = null;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [boardId]);

  const emitCursorMove = (x, y) => {
    const socket = socketRef.current;
    if (!socket || !socket.connected) return;

    const now = Date.now();
    // throttle ~30ms
    if (now - lastCursorEmitRef.current < 30) return;
    lastCursorEmitRef.current = now;

    socket.emit("cursorMove", { boardId, x, y });
  };

  const onPointerDown = (e) => {
    e.preventDefault();
    const p = getCanvasPoint(e);
    drawingRef.current = true;
    lastPointRef.current = p;
    emitCursorMove(p.x, p.y);
  };

  const onPointerMove = (e) => {
    e.preventDefault();
    const p = getCanvasPoint(e);
    emitCursorMove(p.x, p.y);

    if (!drawingRef.current) return;

    const prev = lastPointRef.current;
    const effectiveColor = tool === "eraser" ? "#ffffff" : color;
    const effectiveWidth = tool === "eraser" ? Math.max(10, width * 3) : width;

    const segment = {
      x0: prev.x,
      y0: prev.y,
      x1: p.x,
      y1: p.y,
      color: effectiveColor,
      width: effectiveWidth,
    };

    segmentsRef.current.push(segment);
    drawSegment(segment);

    const socket = socketRef.current;
    if (socket && socket.connected) {
      socket.emit("draw", { boardId, segment });
    }

    lastPointRef.current = p;
  };

  const onPointerUp = (e) => {
    e.preventDefault();
    drawingRef.current = false;
  };

  const handleCopyLink = async () => {
    try {
      await navigator.clipboard.writeText(window.location.href);
      setStatusMsg("Link copied âœ…");
      setTimeout(() => setStatusMsg(""), 700);
    } catch {
      setStatusMsg("Could not copy link.");
    }
  };

  const handleClearBoard = () => {
    const socket = socketRef.current;
    if (!socket || !socket.connected) return;

    if (!window.confirm("Clear the board for everyone?")) return;
    socket.emit("clearBoard", { boardId });
  };

  // (optional) hide stale cursors after 8s
  useEffect(() => {
    const t = setInterval(() => {
      const now = Date.now();
      setCursors((prev) => {
        const copy = { ...prev };
        for (const [uid, c] of Object.entries(copy)) {
          if (now - (c.ts || 0) > 8000) delete copy[uid];
        }
        return copy;
      });
    }, 2000);
    return () => clearInterval(t);
  }, []);

  return (
    <div className="min-h-screen bg-base-200 flex flex-col">
      <NavBar />

      <main className="flex-1">
        <div className="max-w-6xl mx-auto px-4 py-6">
          <div className="flex items-center justify-between gap-3 mb-4">
            <div>
              <h1 className="text-2xl font-bold">Whiteboard</h1>
              <p className="text-sm text-neutral-500">
                Live drawing + autosave + live cursors.
              </p>
            </div>

            <div className="flex gap-2">
              <button
                className="btn btn-ghost btn-sm"
                onClick={() => navigate(`/workspaces/${id}/boards`)}
              >
                Back to boards
              </button>
            </div>
          </div>

          <div className="card bg-base-100 shadow-md mb-4">
            <div className="card-body flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
              <div className="flex items-center gap-3 flex-wrap">
                <div className="join">
                  <button
                    className={`btn btn-sm join-item ${
                      tool === "pen" ? "btn-primary" : "btn-ghost"
                    }`}
                    onClick={() => setTool("pen")}
                    type="button"
                  >
                    Pen
                  </button>
                  <button
                    className={`btn btn-sm join-item ${
                      tool === "eraser" ? "btn-primary" : "btn-ghost"
                    }`}
                    onClick={() => setTool("eraser")}
                    type="button"
                  >
                    Eraser
                  </button>
                </div>

                <label className="text-sm">
                  Color{" "}
                  <input
                    type="color"
                    value={color}
                    onChange={(e) => setColor(e.target.value)}
                    className="ml-2 align-middle"
                    disabled={tool === "eraser"}
                  />
                </label>

                <label className="text-sm">
                  Width{" "}
                  <input
                    type="range"
                    min="1"
                    max="10"
                    value={width}
                    onChange={(e) => setWidth(Number(e.target.value))}
                    className="ml-2 align-middle"
                  />
                  <span className="ml-2 text-xs text-neutral-500">{width}</span>
                </label>
              </div>

              <div className="flex items-center gap-2 flex-wrap">
                <button className="btn btn-ghost btn-sm" onClick={handleCopyLink}>
                  Copy link
                </button>
                <button className="btn btn-ghost btn-sm" onClick={handleClearBoard}>
                  Clear
                </button>
                {statusMsg && (
                  <span className="text-sm text-neutral-500 ml-2">{statusMsg}</span>
                )}
              </div>
            </div>
          </div>

          <div className="card bg-base-100 shadow-md">
            <div className="card-body">
              {/* Canvas wrapper so we can overlay cursors */}
              <div className="w-full relative">
                <canvas
                  ref={canvasRef}
                  className="w-full border border-base-300 rounded-md touch-none bg-white"
                  onMouseDown={onPointerDown}
                  onMouseMove={onPointerMove}
                  onMouseUp={onPointerUp}
                  onMouseLeave={onPointerUp}
                  onTouchStart={onPointerDown}
                  onTouchMove={onPointerMove}
                  onTouchEnd={onPointerUp}
                />

                {/* Live cursors overlay */}
                <div className="absolute inset-0 pointer-events-none">
                  {Object.entries(cursors).map(([userId, c]) => (
                    <div
                      key={userId}
                      style={{
                        position: "absolute",
                        left: c.x,
                        top: c.y,
                        transform: "translate(8px, 8px)",
                      }}
                    >
                      <div className="flex items-center gap-2">
                        <span
                          style={{
                            width: 10,
                            height: 10,
                            borderRadius: 999,
                            background: c.color,
                            display: "inline-block",
                            border: "2px solid white",
                          }}
                        />
                        <span
                          style={{
                            fontSize: 12,
                            padding: "2px 6px",
                            borderRadius: 8,
                            background: "rgba(255,255,255,0.9)",
                            border: `1px solid ${c.color}`,
                            color: "#111827",
                            whiteSpace: "nowrap",
                          }}
                        >
                          {c.name}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>

              <p className="text-xs text-neutral-500 mt-3">
                Tip: cursors show only while users are moving their mouse on the board.
              </p>
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}

export default WhiteboardPage;


===== FILE: frontend\src\pages\WorkspaceBoardsPage.jsx =====
import { useEffect, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import NavBar from "../components/NavBar";
import { isLoggedIn } from "../lib/auth";
import api from "../lib/api";

function WorkspaceBoardsPage() {
  const navigate = useNavigate();
  const { id } = useParams(); // workspaceId

  const [boards, setBoards] = useState([]);
  const [loadingBoards, setLoadingBoards] = useState(true);
  const [error, setError] = useState("");
  const [creating, setCreating] = useState(false);

  useEffect(() => {
    if (!isLoggedIn()) {
      navigate("/login");
    }
  }, [navigate]);

  const fetchBoards = async () => {
    const token = localStorage.getItem("token");
    if (!token) return;

    setError("");
    setLoadingBoards(true);
    try {
      const res = await api.get(`/boards/workspace/${id}`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      setBoards(Array.isArray(res.data) ? res.data : []);
    } catch (e) {
      setError(e?.response?.data?.message || "Failed to load boards.");
    } finally {
      setLoadingBoards(false);
    }
  };

  useEffect(() => {
    fetchBoards();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id]);

  const handleCreateBoard = async () => {
    const token = localStorage.getItem("token");
    if (!token) return;

    setCreating(true);
    setError("");
    try {
      const res = await api.post(
        "/boards",
        { workspaceId: id, title: "New Board" },
        { headers: { Authorization: `Bearer ${token}` } }
      );

      const board = res.data;
      navigate(`/workspaces/${id}/boards/${board._id}`);
    } catch (e) {
      setError(e?.response?.data?.message || "Failed to create board.");
    } finally {
      setCreating(false);
    }
  };

  return (
    <div className="min-h-screen bg-base-200 flex flex-col">
      <NavBar />

      <main className="flex-1">
        <div className="max-w-5xl mx-auto px-4 py-6">
          <div className="flex items-center justify-between mb-6">
            <div>
              <h1 className="text-2xl font-bold">Boards</h1>
              <p className="text-sm text-neutral-500">
                Create a new board, view previous boards, or choose a template.
              </p>
            </div>

            <button
              className="btn btn-ghost btn-sm"
              onClick={() => navigate(`/workspaces/${id}`)}
            >
              Back to workspace
            </button>
          </div>

          {error && (
            <div className="alert alert-error py-2 text-sm mb-4">
              <span>{error}</span>
            </div>
          )}

          {/* Create board */}
          <div className="card bg-base-100 shadow-md mb-6">
            <div className="card-body flex flex-row items-center justify-between">
              <div>
                <h2 className="text-lg font-semibold">Create a new board</h2>
                <p className="text-sm text-neutral-500">
                  Opens a real-time whiteboard.
                </p>
              </div>
              <button
                className={`btn btn-primary ${creating ? "btn-disabled" : ""}`}
                onClick={handleCreateBoard}
                disabled={creating}
              >
                {creating ? "Creating..." : "Create board"}
              </button>
            </div>
          </div>

          {/* Previous boards */}
          <div className="card bg-base-100 shadow-md mb-6">
            <div className="card-body">
              <h2 className="text-lg font-semibold mb-3">Previous boards</h2>

              {loadingBoards ? (
                <div className="rounded-box border border-base-300 p-6 bg-base-100 text-sm text-neutral-500">
                  Loading boards...
                </div>
              ) : boards.length === 0 ? (
                <div className="rounded-box border border-dashed border-base-300 p-6 text-sm text-neutral-500">
                  No boards yet.
                </div>
              ) : (
                <div className="grid gap-3 md:grid-cols-2">
                  {boards.map((b) => (
                    <div
                      key={b._id}
                      className="card bg-base-200 cursor-pointer hover:shadow transition"
                      onClick={() => navigate(`/workspaces/${id}/boards/${b._id}`)}
                    >
                      <div className="card-body py-4">
                        <div className="font-semibold">{b.title}</div>
                        <div className="text-xs text-neutral-500">
                          Updated: {new Date(b.updatedAt).toLocaleString()}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>

          {/* Templates (placeholder) */}
          <div className="card bg-base-100 shadow-md">
            <div className="card-body">
              <h2 className="text-lg font-semibold mb-2">Templates</h2>
              <div className="rounded-box border border-dashed border-base-300 p-6 text-sm text-neutral-500">
                Templates will appear here.
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}

export default WorkspaceBoardsPage;


===== FILE: frontend\src\pages\WorkspaceDetailsPage.jsx =====
import { useEffect, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import NavBar from "../components/NavBar";
import api from "../lib/api";
import { isLoggedIn, getUser } from "../lib/auth";
import WorkspaceChat from "../components/WorkspaceChat";

function WorkspaceDetailsPage() {
  const { id } = useParams();
  const navigate = useNavigate();

  const currentUser = getUser();

  const [workspace, setWorkspace] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  const [inviteEmailsText, setInviteEmailsText] = useState("");
  const [inviteMessage, setInviteMessage] = useState("");
  const [inviteError, setInviteError] = useState("");
  const [inviteLoading, setInviteLoading] = useState(false);

  const [actionMessage, setActionMessage] = useState("");
  const [actionError, setActionError] = useState("");

  const token =
    typeof window !== "undefined" ? localStorage.getItem("token") : null;

  const loadWorkspace = async () => {
    if (!token) return;
    setError("");
    setLoading(true);
    try {
      const res = await api.get(`/workspaces/${id}`, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      setWorkspace(res.data);
    } catch (err) {
      const msg = err?.response?.data?.message || "Failed to load workspace.";
      setError(msg);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (!isLoggedIn() || !token) {
      navigate("/login");
      return;
    }
    loadWorkspace();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id, navigate]);

  const isOwner =
    workspace &&
    workspace.owner &&
    currentUser &&
    workspace.owner._id === currentUser.id;

  const handleInvite = async (e) => {
    e.preventDefault();
    setInviteError("");
    setInviteMessage("");

    if (!inviteEmailsText.trim()) {
      setInviteError("Please enter at least one email.");
      return;
    }

    const memberEmails = inviteEmailsText
      .split(",")
      .map((x) => x.trim())
      .filter((x) => x.length > 0);

    if (memberEmails.length === 0) {
      setInviteError("Please enter valid email(s).");
      return;
    }

    if (!token) {
      setInviteError("Not authenticated.");
      return;
    }

    setInviteLoading(true);
    try {
      const res = await api.post(
        `/workspaces/${id}/invite`,
        { memberEmails },
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );
      setInviteMessage(res.data.message || "Invitations sent.");
      setInviteEmailsText("");
    } catch (err) {
      const msg = err?.response?.data?.message || "Failed to send invitations.";
      setInviteError(msg);
    } finally {
      setInviteLoading(false);
    }
  };

  const handleRoleChange = async (memberId, newRole) => {
    setActionError("");
    setActionMessage("");

    if (!token) {
      setActionError("Not authenticated.");
      return;
    }

    try {
      await api.patch(
        `/workspaces/${id}/members/${memberId}/role`,
        { role: newRole },
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );
      setActionMessage("Member role updated.");
      await loadWorkspace();
    } catch (err) {
      const msg =
        err?.response?.data?.message || "Failed to update member role.";
      setActionError(msg);
    }
  };

  const handleRemoveMember = async (memberId) => {
    setActionError("");
    setActionMessage("");

    if (!window.confirm("Remove this member from the workspace?")) return;

    if (!token) {
      setActionError("Not authenticated.");
      return;
    }

    try {
      await api.delete(`/workspaces/${id}/members/${memberId}`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      setActionMessage("Member removed from workspace.");
      await loadWorkspace();
    } catch (err) {
      const msg = err?.response?.data?.message || "Failed to remove member.";
      setActionError(msg);
    }
  };

  const renderStatusDot = (isOnline) => (
    <span
      className={`inline-block w-2 h-2 rounded-full mr-2 ${
        isOnline ? "bg-green-500" : "bg-red-500"
      }`}
    />
  );

  return (
    <div className="min-h-screen bg-base-200 flex flex-col">
      <NavBar />

      <main className="flex-1">
        <div className="max-w-5xl mx-auto px-4 py-6">
          {loading ? (
            <div className="rounded-box border border-base-300 p-6 bg-base-100 text-sm text-neutral-500">
              Loading workspace...
            </div>
          ) : error ? (
            <div className="alert alert-error py-2 text-sm">
              <span>{error}</span>
            </div>
          ) : !workspace ? (
            <div className="rounded-box border border-base-300 p-6 bg-base-100 text-sm text-neutral-500">
              Workspace not found.
            </div>
          ) : (
            <>
              {/* Header: Workspace info + actions */}
              <div className="mb-6">
                <div className="flex items-start justify-between gap-3">
                  <div className="flex-1">
                    <h1 className="text-2xl font-bold mb-1">{workspace.name}</h1>
                    {workspace.description && (
                      <p className="text-sm text-neutral-600">
                        {workspace.description}
                      </p>
                    )}
                  </div>

                  {/* Keep ALL features: Boards + Voice */}
                  <div className="flex items-center gap-2">
                    <button
                      className="btn btn-primary btn-sm"
                      onClick={() => navigate(`/workspaces/${id}/boards`)}
                    >
                      Boards
                    </button>

                    <button
                      className="btn btn-primary btn-sm"
                      onClick={() => navigate(`/workspaces/${id}/voice`)}
                    >
                      Join Voice Chat
                    </button>
                  </div>
                </div>
              </div>

              {(actionError || actionMessage) && (
                <div className="mb-4 space-y-2">
                  {actionError && (
                    <div className="alert alert-error py-2 text-sm">
                      <span>{actionError}</span>
                    </div>
                  )}
                  {actionMessage && (
                    <div className="alert alert-success py-2 text-sm">
                      <span>{actionMessage}</span>
                    </div>
                  )}
                </div>
              )}

              <div className="grid gap-6 lg:grid-cols-3">
                {/* Members */}
                <div className="card bg-base-100 shadow-md lg:col-span-2">
                  <div className="card-body">
                    <h2 className="card-title text-base mb-2">
                      Workspace Members
                    </h2>
                    <ul className="space-y-3 text-sm">
                      {workspace.members && workspace.members.length > 0 ? (
                        workspace.members.map((m) => {
                          const isCurrentUser =
                            currentUser && m._id === currentUser.id;

                          return (
                            <li
                              key={m._id}
                              className="flex flex-col border-b border-base-200 pb-2 last:border-0"
                            >
                              <div className="flex items-center justify-between">
                                <div className="flex items-center">
                                  {renderStatusDot(m.isOnline)}
                                  <div>
                                    <div className="font-medium">
                                      {m.name}
                                      {isCurrentUser && (
                                        <span className="text-xs text-neutral-500 ml-1">
                                          (you)
                                        </span>
                                      )}
                                    </div>
                                    <div className="text-xs text-neutral-500">
                                      {m.email}
                                    </div>
                                  </div>
                                </div>

                                <div className="flex items-center gap-2">
                                  {isOwner ? (
                                    <select
                                      className="select select-xs select-bordered"
                                      value={m.role}
                                      disabled={isCurrentUser && m.role === "owner"}
                                      onChange={(e) =>
                                        handleRoleChange(m._id, e.target.value)
                                      }
                                    >
                                      <option value="owner">Owner</option>
                                      <option value="editor">Editor</option>
                                      <option value="viewer">Viewer</option>
                                    </select>
                                  ) : (
                                    <span className="badge badge-outline">
                                      {m.role}
                                    </span>
                                  )}

                                  {/* Owner only; cannot remove self as owner */}
                                  {isOwner &&
                                    !(m.role === "owner" && isCurrentUser) && (
                                      <button
                                        className="btn btn-xs btn-ghost"
                                        onClick={() => handleRemoveMember(m._id)}
                                      >
                                        Remove
                                      </button>
                                    )}
                                </div>
                              </div>
                            </li>
                          );
                        })
                      ) : (
                        <li className="text-neutral-500 text-sm">
                          No members yet.
                        </li>
                      )}
                    </ul>
                  </div>
                </div>

                {/* Right column: owner + invite */}
                <div className="space-y-4">
                  <div className="card bg-base-100 shadow-md">
                    <div className="card-body">
                      <h2 className="card-title text-base mb-2">
                        Workspace Owner
                      </h2>
                      {workspace.owner ? (
                        <div className="flex items-center gap-2 text-sm">
                          {renderStatusDot(workspace.owner.isOnline)}
                          <div>
                            <div className="font-medium">
                              {workspace.owner.name}
                              {currentUser &&
                                workspace.owner._id === currentUser.id && (
                                  <span className="text-xs text-neutral-500 ml-1">
                                    (you)
                                  </span>
                                )}
                            </div>
                            <div className="text-xs text-neutral-500">
                              {workspace.owner.email}
                            </div>
                          </div>
                        </div>
                      ) : (
                        <p className="text-sm text-neutral-500">
                          Owner information not available.
                        </p>
                      )}
                    </div>
                  </div>

                  {isOwner && (
                    <div className="card bg-base-100 shadow-md">
                      <div className="card-body">
                        <h2 className="card-title text-base mb-2">
                          Invite Members
                        </h2>
                        {inviteError && (
                          <div className="alert alert-error py-2 text-xs mb-2">
                            <span>{inviteError}</span>
                          </div>
                        )}
                        {inviteMessage && (
                          <div className="alert alert-success py-2 text-xs mb-2">
                            <span>{inviteMessage}</span>
                          </div>
                        )}
                        <form onSubmit={handleInvite} className="space-y-2">
                          <textarea
                            className="textarea textarea-bordered w-full text-sm"
                            rows={3}
                            value={inviteEmailsText}
                            onChange={(e) => setInviteEmailsText(e.target.value)}
                            placeholder="example1@mail.com, example2@mail.com"
                          />
                          <p className="text-xs text-neutral-500">
                            Separate emails with commas. Invitations are only
                            sent to users who already registered.
                          </p>
                          <button
                            type="submit"
                            className={`btn btn-primary btn-sm ${
                              inviteLoading ? "btn-disabled" : ""
                            }`}
                            disabled={inviteLoading}
                          >
                            {inviteLoading ? "Sending..." : "Invite members"}
                          </button>
                        </form>
                      </div>
                    </div>
                  )}
                </div>
              </div>

              {/* Chat */}
              <div className="mt-6">
                <WorkspaceChat workspaceId={id} />
              </div>
            </>
          )}
        </div>
      </main>
    </div>
  );
}

export default WorkspaceDetailsPage;

